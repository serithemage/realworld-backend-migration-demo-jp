# Chapter 1: ユーザー管理と認証 (ユーザーかんりと にんしょう)


このRealworldバックエンドプロジェクトへようこそ！このチュートリアルシリーズでは、既存のバックエンドアプリケーションがどのように構築されているかを一緒に見ていきます。最初の章では、すべてのウェブアプリケーションの基本となる「ユーザー管理と認証」機能について学びます。

## ユーザー管理と認証ってなに？

ウェブサイトやアプリを使ったことがあるなら、「新規登録」や「ログイン」といった画面を見たことがあるでしょう。ユーザー管理と認証は、まさにこれらの機能を提供します。

私たちのプロジェクトでは、ユーザーが新しくアカウントを作成したり（新規登録）、既存のアカウントでサインインしたり（ログイン）、自分のアカウント情報を見たり更新したりする機能があります。

これを大きなイベント会場に例えてみましょう。
*   **ユーザー登録**: イベントの参加申し込みです。名前や連絡先を登録します。
*   **ログイン**: イベント当日の受付です。登録情報と照合して本人確認をします。
*   **認証**: 本人確認が成功することです。
*   **トークン発行**: 受付で渡される入場パスやリストバンドのようなものです。これを持っていると、会場内の特定のエリアに入れます。
*   **ユーザー情報**: 参加者リストに書かれたあなたの情報（名前、メールアドレスなど）です。

このプロジェクトの面白いところは、これらの受付業務（認証・認可）を専門の外部サービスである **Keycloak** に任せている点です。Keycloakが、ユーザーの本人確認を行い、適切なアクセス権（トークン）を発行して、アプリケーションの各機能へのアクセスを許可する役割を担います。

この章では、主にこのKeycloakとの連携部分に焦点を当てて、ユーザーがどのように登録され、ログインし、情報を扱えるようになるのかを見ていきます。

## どうやって使うの？ (APIエンドポイント)

ユーザー管理機能は、主に以下のAPIエンドポイントを通じて提供されます。

### 1. ユーザー新規登録 (`POST /users`)

新しいユーザーがアプリケーションに登録するための機能です。

**リクエスト例 (入力):**

ユーザー名、メールアドレス、パスワードをJSON形式で送ります。

```json
{
  "user": {
    "username": "新しいユーザー",
    "email": "user@example.com",
    "password": "password123"
  }
}
```

**レスポンス例 (出力):**

登録されたユーザー情報と、今後認証に使う「トークン」が返されます。

```json
{
  "user": {
    "email": "user@example.com",
    "username": "新しいユーザー",
    "bio": null,
    "image": null,
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." // とても長い文字列
  }
}
```
このトークンは、イベント会場の入場パスのようなものです。これを持っていると、ログインが必要な他の機能を利用できます。

**関連コード (コントローラー):**

`UsersController.java` の `registerUser` メソッドがこのリクエストを処理します。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/users/controllers/UsersController.java
@PostMapping("/users")
@ResponseStatus(HttpStatus.CREATED)
public UserResponse registerUser(@RequestBody RegisterUserRequest request)
        throws AlreadyExistsException {
    var user =
            usersService.createUser( // ユーザーサービスを呼び出してユーザーを作成
                    request.user.username, request.user.email, request.user.password);

    var token = usersService.getToken(user.getUsername(), request.user.password); // トークンを取得

    return new UserResponse(user, token); // ユーザー情報とトークンを返す
}
```
このコードは、リクエストで受け取った情報を使って `usersService` (詳細は後述) にユーザー作成とトークン発行を依頼し、その結果を返しています。

`RegisterUserRequest.java` はリクエストのデータを保持するためのシンプルなクラスです。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/users/controllers/dto/RegisterUserRequest.java
public final class RegisterUserRequest {
    public RegisterUserRequestUser user;
    // ... コンストラクタなど ...
    public static final class RegisterUserRequestUser {
        public String username;
        public String email;
        public String password;
        // ... コンストラクタなど ...
    }
}
```

### 2. ログイン (`POST /users/login`)

既に登録済みのユーザーがログインするための機能です。

**リクエスト例 (入力):**

メールアドレスとパスワードを送ります。

```json
{
  "user": {
    "email": "user@example.com",
    "password": "password123"
  }
}
```

**レスポンス例 (出力):**

ユーザー情報と新しいトークンが返されます。

```json
{
  "user": {
    "email": "user@example.com",
    "username": "新しいユーザー",
    "bio": null,
    "image": null,
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." // 新しいトークン
  }
}
```

**関連コード (コントローラー):**

`UsersController.java` の `login` メソッドが担当します。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/users/controllers/UsersController.java
@PostMapping("/users/login")
public UserResponse login(@RequestBody LoginRequest request) {
    var user = usersService.getUserByEmail(request.user.email).orElse(null); // メールでユーザー検索

    if (user == null) {
        throw new NotFoundException("User with email '" + request.user.email + "' not found");
    }

    var token = usersService.getToken(user.getUsername(), request.user.password); // トークン取得

    return new UserResponse(user, token);
}
```
登録時と同様に、`usersService` を使ってユーザー情報を取得し、トークンを発行しています。

`LoginRequest.java` はログインリクエストのデータを保持します。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/users/controllers/dto/LoginRequest.java
public final class LoginRequest {
    public LoginRequestUser user;
    // ... コンストラクタなど ...
    public static class LoginRequestUser {
        public String email;
        public String password;
        // ... コンストラクタなど ...
    }
}
```

### 3. 現在のユーザー情報を取得 (`GET /user`)

ログイン中のユーザーが自身の情報を取得するための機能です。この機能を利用するには、リクエストヘッダーに有効なトークンを含める必要があります。

**リクエストヘッダー例:**

```
Authorization: Token eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**レスポンス例 (出力):**

現在のユーザー情報と、場合によっては更新されたトークンが返されます。

```json
{
  "user": {
    "email": "user@example.com",
    "username": "新しいユーザー",
    "bio": "自己紹介文です。",
    "image": "http://example.com/image.png",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
}
```

**関連コード (コントローラー):**

`UsersController.java` の `getCurrentUser` メソッドが担当します。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/users/controllers/UsersController.java
@GetMapping("/user")
public UserResponse getCurrentUser(
        @RequestHeader(name = "Authorization") String authorizationHeader) { // ヘッダーからトークン取得
    var authentication = authenticationFacade.getAuthentication(); // 認証情報を取得
    var userId = authentication.getName(); // 認証情報からユーザーIDを取得

    var user = usersService.getUserById(userId).orElse(null); // IDでユーザーを検索

    // ... ユーザーが見つからない場合のエラー処理 ...

    var token = authorizationHeader.split(" ")[1]; // ヘッダーからトークン文字列を抽出

    return new UserResponse(user, token);
}
```
ここでは `authenticationFacade` というコンポーネントが登場し、トークンから認証済みのユーザー情報を取得しています。

### 4. ユーザー情報更新 (`PUT /user`)

ログイン中のユーザーが自身の情報（メールアドレス、ユーザー名、パスワード、自己紹介、プロフィール画像URL）を更新するための機能です。これもトークンが必要です。

**リクエスト例 (入力):**

更新したい情報だけを送ります。

```json
{
  "user": {
    "email": "new.email@example.com",
    "bio": "新しい自己紹介です。",
    "image": "http://example.com/new_image.png"
  }
}
```

**レスポンス例 (出力):**

更新後のユーザー情報とトークンが返されます。

```json
{
  "user": {
    "email": "new.email@example.com",
    "username": "新しいユーザー", // ユーザー名は変更していない
    "bio": "新しい自己紹介です。",
    "image": "http://example.com/new_image.png",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
}
```

**関連コード (コントローラー):**

`UsersController.java` の `updateUser` メソッドが担当します。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/users/controllers/UsersController.java
@PutMapping("/user")
@Transactional
public UserResponse updateUser(
        @RequestHeader(name = "Authorization") String authorizationHeader,
        @RequestBody UpdateUserRequest request) // 更新情報
        throws AlreadyExistsException {
    var authentication = authenticationFacade.getAuthentication();
    var userId = authentication.getName();

    var user = usersService.updateUser(userId, /* 更新内容を渡す */)
                   .orElse(null);

    // ... ユーザーが見つからない場合のエラー処理 ...

    var token = authorizationHeader.split(" ")[1];
    return new UserResponse(user, token);
}
```
`UpdateUserRequest.java` は更新リクエストのデータを保持します。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/users/controllers/dto/UpdateUserRequest.java
public final class UpdateUserRequest {
    public UpdateUserRequestUser user;
    // ... コンストラクタなど ...
    public static final class UpdateUserRequestUser {
        public String email;
        public String username;
        public String password; // 新しいパスワード
        public String bio;
        public String image;
        // ... コンストラクタなど ...
    }
}
```

### 共通のデータ構造

上記のレスポンスで共通して使われている `UserResponse` や `User` についても見てみましょう。

`UserResponse.java`: APIレスポンスの形式を定義します。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/users/controllers/dto/UserResponse.java
public final class UserResponse {
    private final UserResponseUser user; // ネストされたユーザー情報

    public UserResponse(User user, String token) {
        this.user = new UserResponseUser(user, token);
    }
    // ... ゲッター ...
    public static final class UserResponseUser { // 実際に返されるユーザー情報
        private final String email;
        private final String username;
        private final String token;
        private final String bio;
        private final String image;
        // ... コンストラクタとゲッター ...
    }
}
```

`User.java`: アプリケーション内部でユーザー情報を表現するためのクラスです。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/users/models/User.java
public class User {
    private final String id; // Keycloak内のID
    private final String email;
    private final String username;
    private final Optional<String> bio; // 自己紹介文 (オプショナル)
    private final Optional<String> image; // 画像URL (オプショナル)

    // ... コンストラクタとゲッター ...

    // Keycloakからの情報をもとにUserオブジェクトを作成するコンストラクタ
    public User(UserRepresentation userRepresentation) {
        this(
                userRepresentation.getId(),
                userRepresentation.getEmail(),
                userRepresentation.getUsername(),
                Optional.ofNullable(userRepresentation.firstAttribute("bio")),
                Optional.ofNullable(userRepresentation.firstAttribute("image")));
    }
}
```
`UserRepresentation` はKeycloakがユーザー情報を表現する際に使うクラスです。`User`クラスは、この `UserRepresentation` から必要な情報を取り出して、アプリケーションで扱いやすい形に変換します。

## 内部の仕組み: Keycloakとの連携

これらのユーザー管理機能は、どのように実現されているのでしょうか？中心となるのは外部の認証サービス **Keycloak** との連携です。

### 処理の流れ (ざっくりと)

ユーザー登録やログインの際、私たちのアプリケーションはKeycloakと通信します。

**ユーザー登録の例:**

```mermaid
sequenceDiagram
    participant Client as クライアント (ブラウザなど)
    participant App as Realworldアプリ
    participant KeycloakSvc as Keycloakサービス

    Client->>App: POST /users (ユーザー名, メール, パスワード)
    App->>KeycloakSvc: ユーザー作成リクエスト (ユーザー名, メール)
    KeycloakSvc-->>App: ユーザー作成成功 (ユーザーID)
    App->>KeycloakSvc: パスワード設定リクエスト (ユーザーID, パスワード)
    KeycloakSvc-->>App: パスワード設定成功
    App->>KeycloakSvc: トークン発行リクエスト (ユーザー名, パスワード)
    KeycloakSvc-->>App: アクセストークン
    App-->>Client: ユーザー情報 + アクセストークン
```

1.  **クライアント** (ユーザーのブラウザなど) が、新しいユーザー情報をRealworldアプリに送信します。
2.  **Realworldアプリ** は、受け取った情報を元に、Keycloakサービスに「こういうユーザーを新しく作ってください」とお願いします。
3.  **Keycloakサービス** はユーザーを作成し、そのユーザーのIDをRealworldアプリに返します。
4.  **Realworldアプリ** は、次にKeycloakサービスに「先ほど作ったユーザーのパスワードをこれに設定してください」とお願いします。
5.  **Keycloakサービス** はパスワードを設定します。
6.  **Realworldアプリ** は、最後にKeycloakサービスに「このユーザー名とパスワードでログインするためのトークンを発行してください」とお願いします。
7.  **Keycloakサービス** はアクセストークン（入場パス）を発行し、Realworldアプリに渡します。
8.  **Realworldアプリ** は、ユーザー情報と受け取ったアクセストークンをクライアントに返します。

ログインの場合は、主に上記の 6, 7, 8 のステップ（トークン発行）が行われます。

### `UsersService.java`: Keycloakとの対話役

実際のKeycloakとの通信は、`UsersService`クラスが担当します。このクラスには、ユーザーを作成したり、情報を取得したり、トークンを取得したりするためのメソッドが含まれています。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/users/services/users/UsersService.java
@Service
public class UsersService {
    // ... (Keycloak接続情報: サーバーURL, レルム名, クライアントIDなど) ...
    private Keycloak keycloakAdminInstance; // 管理操作用のKeycloakインスタンス

    @PostConstruct // このサービスが作られた後に実行される
    public void initKeycloak() {
        // Keycloakの管理クライアントを初期化・設定
        keycloakAdminInstance = KeycloakBuilder.builder()
                // ... 接続情報を使って設定 ...
                .build();
    }

    @PreDestroy // このサービスが破棄される前に実行される
    public void closeKeycloak() {
        keycloakAdminInstance.close(); // Keycloakインスタンスを閉じる
    }

    public User createUser(String username, String email, String password)
            throws AlreadyExistsException {
        // ... (バリデーション処理) ...
        var usersResource = keycloakAdminInstance.realm(keycloakRealm).users(); // Keycloakのユーザー管理API

        var userRepresentation = new UserRepresentation(); // Keycloak用のユーザー表現
        userRepresentation.setUsername(username);
        userRepresentation.setEmail(email);
        userRepresentation.setEnabled(true);

        var createUserResponse = usersResource.create(userRepresentation); // Keycloakにユーザー作成を依頼
        var userId = CreatedResponseUtil.getCreatedId(createUserResponse);

        // パスワード設定
        var passwordCredential = makePasswordCredentialRepresentation(password);
        usersResource.get(userId).resetPassword(passwordCredential); // Keycloakにパスワード設定を依頼

        return new User(userRepresentation); // アプリケーション用のUserオブジェクトを返す
    }

    public String getToken(String username, String password) {
        // ユーザー自身の資格情報でKeycloakインスタンスを作成
        var keycloakInstance = Keycloak.getInstance(
            keycloakServerUrl, keycloakRealm, username, password, keycloakClientId, keycloakClientSecret);
        try {
            return keycloakInstance.tokenManager().grantToken().getToken(); // トークンを発行してもらう
        } finally {
            keycloakInstance.close();
        }
    }

    // ... getUserByEmail, getUserById, updateUserなどのメソッド ...
    // これらも同様に keycloakAdminInstance を使ってKeycloakと通信します。
}
```
*   `initKeycloak()`: `UsersService`が起動する際に、Keycloakの管理用APIクライアント (`keycloakAdminInstance`) を初期化します。このクライアントを使って、ユーザーの作成や検索などを行います。
*   `createUser()`: `UserRepresentation` というKeycloakが理解できる形式でユーザー情報を作成し、`usersResource.create()` を呼び出してKeycloakにユーザーを登録します。その後、パスワードも設定します。
*   `getToken()`: ログイン時には、ユーザー名とパスワードを使ってKeycloakから直接トークンを取得します。この時は管理用クライアントではなく、ユーザー自身の資格情報でKeycloakに接続します。

### `SecurityConfig.java`: アプリケーションの門番

ログイン後、ユーザーが他の機能（例：記事の投稿、プロフィールの更新など）にアクセスする際には、リクエストヘッダーにトークンを付けて送信する必要があります。アプリケーションは、このトークンが有効かどうかをKeycloakに問い合わせて検証します。

この「どのリクエストに認証が必要か」「トークンをどう検証するか」といったセキュリティ設定は、`SecurityConfig.java` で行われます。これは[セキュリティ設定 (セキュリティせってい)](06_セキュリティ設定__セキュリティせってい__.md)の章で詳しく学びますが、ここではユーザー管理に関連する部分だけ見てみましょう。

```java
// src/main/java/com/marcusmonteirodesouza/realworld/api/security/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable()) // CSRF保護を無効化 (APIなので)
            .authorizeHttpRequests(authz -> authz
                .requestMatchers(HttpMethod.POST, "/users").permitAll() // ユーザー登録は誰でもOK
                .requestMatchers(HttpMethod.POST, "/users/login").permitAll() // ログインは誰でもOK
                // ... 他の公開エンドポイント (プロフィール参照、記事一覧など) ...
                .anyRequest().authenticated() // それ以外は認証が必要
            );

        http.sessionManagement(session -> session
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS) // セッションを使わない (トークンベースなので)
        );

        http.oauth2ResourceServer(oauth2 -> oauth2 // OAuth2/JWTトークン認証を設定
            .bearerTokenResolver(request -> { // "Authorization: Token <token>" ヘッダーからトークンを抽出
                var header = request.getHeader(HttpHeaders.AUTHORIZATION);
                if (header == null || header.isBlank() || !header.startsWith("Token ")) {
                    return null;
                }
                return header.split("Token ")[1].trim();
            })
            .jwt(Customizer.withDefaults()) // JWTの検証設定 (Keycloakと連携)
        );
        return http.build();
    }
}
```
*   `authorizeHttpRequests`:
    *   `/users` (ユーザー登録) と `/users/login` (ログイン) への `POST` リクエストは `permitAll()` で、誰でもアクセスできるように設定されています。
    *   `anyRequest().authenticated()` で、上記以外のすべてのリクエストは認証（有効なトークン）が必要であることを示しています。
*   `oauth2ResourceServer`:
    *   Keycloakが発行するJWT（JSON Web Token）を検証するように設定しています。
    *   `bearerTokenResolver`: Realworldの仕様では、トークンは `Authorization: Token <actual_token_value>` という形式のヘッダーで送られてきます。この部分で、そのヘッダーから実際のトークン文字列を抽出する処理を定義しています。Spring Securityはデフォルトでは `Authorization: Bearer <token>` を期待するため、このカスタマイズが必要です。

この設定により、保護されたエンドポイントにトークンなしでアクセスしようとするとエラーになり、トークンがあっても無効なものであればアクセスが拒否されます。

## まとめ

この章では、Realworldバックエンドアプリケーションにおけるユーザー管理と認証の基本的な仕組みを学びました。
*   ユーザーは、`/users` エンドポイントで**新規登録**でき、`/users/login` エンドポイントで**ログイン**できます。
*   これらの操作を行うと、**トークン**が発行されます。このトークンは、認証が必要な他のAPIを利用する際の「入場パス」となります。
*   ユーザー情報の取得 (`/user`) や更新 (`/user`) には、このトークンが必要です。
*   これらの機能の裏側では、**Keycloak** という外部の認証サービスが重要な役割を果たしています。ユーザー情報の保存、パスワード管理、トークン発行・検証はKeycloakが行います。
*   `UsersService` クラスがKeycloakとの通信を担当し、`SecurityConfig` クラスがアプリケーション全体のセキュリティルール（どのAPIに認証が必要かなど）を定義しています。

これで、ユーザーがどのようにしてアプリケーションにアクセスし、自分の情報を管理できるようになったのか、その第一歩を理解できたはずです。

次の章では、ユーザーの公開プロフィール情報を扱う[プロフィール管理 (プロフィールかんり)](02_プロフィール管理__プロフィールかんり__.md)について見ていきましょう。

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)